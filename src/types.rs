use serde::Serialize;

/// Lightweight identifier for a market outcome, extracted from SDK Position.
#[derive(Debug, Clone, Serialize)]
pub struct MarketPosition {
    pub condition_id: String,
    pub asset: String,
    pub title: String,
    pub outcome: String,
    pub outcome_index: i32,
    pub event_slug: String,
}

/// Target allocation for one market position.
#[derive(Debug, Clone, Serialize)]
pub struct TargetAllocation {
    pub market: MarketPosition,
    pub trader_weight: f64,
    pub target_value_usd: f64,
    pub target_shares: f64,
    pub cur_price: f64,
}

/// Order direction.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum OrderSide {
    Buy,
    Sell,
}

/// A simulated order generated by the rebalancing engine.
#[derive(Debug, Clone, Serialize)]
pub struct SimulatedOrder {
    pub market: MarketPosition,
    pub side: OrderSide,
    pub shares: f64,
    pub price: f64,
    pub cost_usd: f64,
}

/// A position we currently hold (tracked in TradingState).
#[derive(Debug, Clone, Serialize)]
pub struct HeldPosition {
    pub asset: String,
    pub title: String,
    pub outcome: String,
    pub shares: f64,
    pub total_cost: f64,
    pub avg_cost: f64,
}

/// What triggered a copytrade event.
#[derive(Debug, Clone, Serialize)]
pub enum EventTrigger {
    InitialReplication,
    TradeDetected,
}

/// Status of a live order execution.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize)]
pub enum ExecutionStatus {
    Filled,
    PartialFill,
    Resting,
    Failed,
    Skipped,
}

/// A resting order on the CLOB book that hasn't filled yet.
#[derive(Debug, Clone, Serialize)]
pub struct RestingOrder {
    pub order_id: String,
    pub asset: String,
    pub title: String,
    pub outcome: String,
    pub side: OrderSide,
    pub shares: f64,
    pub price: f64,
    pub cost_usd: f64,
}

/// Result of executing a single order on the CLOB.
#[derive(Debug, Clone, Serialize)]
pub struct ExecutionResult {
    pub order_index: usize,
    pub status: ExecutionStatus,
    pub order_id: String,
    pub filled_shares: f64,
    pub filled_cost_usd: f64,
    pub error_msg: Option<String>,
}

/// Per-event JSON log entry emitted to stdout.
#[derive(Debug, Clone, Serialize)]
pub struct CopytradeEvent {
    pub timestamp: String,
    pub trigger: EventTrigger,
    pub detected_trade_hashes: Vec<String>,
    pub orders: Vec<SimulatedOrder>,
    pub budget_remaining: f64,
    pub total_spent: f64,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_results: Option<Vec<ExecutionResult>>,
}

/// Per-position summary in the exit report.
#[derive(Debug, Clone, Serialize)]
pub struct HoldingSummary {
    pub asset: String,
    pub title: String,
    pub outcome: String,
    pub shares: f64,
    pub avg_cost: f64,
    pub cur_price: f64,
    pub current_value: f64,
    pub unrealized_pnl: f64,
}

/// Exit summary emitted on shutdown.
#[derive(Debug, Clone, Serialize)]
pub struct ExitSummary {
    pub initial_budget: f64,
    pub budget_remaining: f64,
    pub total_spent: f64,
    pub total_sell_proceeds: f64,
    pub realized_pnl: f64,
    pub unrealized_pnl: f64,
    pub total_pnl: f64,
    pub pnl_percent: f64,
    pub total_events: u64,
    pub total_orders: u64,
    pub total_buy_orders: u64,
    pub total_sell_orders: u64,
    pub holdings: Vec<HoldingSummary>,
}
